\section{Design}
The problems that this bachelor thesis wants to address:
An extendable, easy to use visualization library for dynamic data, usable for visual debugging.



\section{Implementation}



\subsubsection{The Julia Programming Language}
Bringing Julia's ease of use and speed to a dynamic visualization library is the declared goal, which makes Julia a crucial building block for this thesis.
Julia is a multi paradigma language for scientific computing.
The focus on scientific computing means, that Julia's standard library is equipped with a lot of functions, data structures and specialized syntax for implementing complex math.


\subsubsection{OpenGL}
OpenGL is a low-level graphics API. As such it doesn't offer much abstraction over the Video hardware, but instead offers high flexibility and performance.


\subsubsection{Reactive}
\subsubsection{GLFW}


\vspace{1em}
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.9\linewidth]{graphics/architecture.pdf}
    \captionof{figure}[Architecture]{Main modules used in Romeo and their relation (simplified)}
    \label{fig:architecture} 
\end{minipage}


This chapter is about the implementation of Romeo.
The Romeo package itself is small and just defines the high-level functionality of the editor.
This includes window layout and connecting all the different event sources to create the wanted behavior.
To do this, Romeo relies on a multitude of packages, which step for step abstract away the underlying low-level code that is used to do the window creation and rendering.
GLVisualize is the main package offering the rendering functionality and the editor widgets like text fields and sliders.
For rendering GLVisualize relies on GLAbstraction, which defines a high-level interface to OpenGL.
OpenGL function loading is done by ModernGL, which keeps all the function and Enums definitions from OpenGL with version higher than 3.0.
The event management is handled by Reactive.

\subsection{Reactive}

Reactive is a functional event system designed for event driven programming.
It implements Elm's signal based event system in Julia.
Signals are values that change over time.
These signals can be transformed via arbitrary functions which creates a new signal. 
This simple principle leads too a surprisingly simple yet effective way of programming event based applications.
\begin{lstlisting}
a = Input(40) # an integer signal.
b = Input(2) # an integer signal.
c = lift(+, a,b) # creates a new signal with the callback plus. Equal to c = a+b
lift(println, c) # executes println, every time that c is updated. 
push!(a, 20) # updates a, resulting in c being 22
#prints: 22
push!(b, 5) # updates a, resulting in c being 22
#prints: 25
\end{lstlisting}
Visualizing dynamic data makes the event system a crucial component of the library.
The event system was challenging to integrate for several reasons.
First of all Reactive is a functional event system, while OpenGL relies heavily on global states, which are two perpendicular concepts.
Also, it doesn't allow to rearrange the event tree. In other words if you have two signal branches, there is no way to fuse them together.
Finally, it doesn't reuse memory for signals. This means, if you have a signal for a large array every lift operation will allocate new memory for the array.
Working around these shortcomings reduced the ease of use of the overall API.
It has lead to two design choices which are sub optimal.
First, the event system is decoupled from the render loop, to set the global OpenGL states appropriately.
This means, that the structure is as follows:
\begin{lstlisting}
#instead of:
a = Input(data)
b = lift(visualize, a)
c = lift(render_opengl, b)
# it is now:
while window.open
	render(b.value)
end
\end{lstlisting}
The sub optimal performance of Reactive for large data has let to the following design:
\begin{lstlisting}
# instead of
a = Input(large_array)
b = lift(some_computation, a, some_timed_signal)
c = lift(visualize, b)
# it is now:
a = visualize(large_array)
lift(some_timed_signal) do time
	b = some_computation(large_array, time)
	update!(a, b) # write directly to the gpu object
end
\end{lstlisting}

\subsection{ModernGL}
OpenGL is implemented by the video card vendor and is shipped via the video driver, which comes in the form of a C-Library.
The challenge is, to load the function pointer system and vendor independently. Also one further complication is, that depending on the platform, function pointer are only available after an OpenGL context was created and may only be valid for this context. \cite{wgl}
This problem is solved, by initializing a function pointer cache with null and as soon as the function is called the first time the real pointer gets loaded. This is suboptimal, as the pointer cannot be inlined and has to be checked for null.
In the newest version of Julia, this can be implemented even more efficiently with staged functions. Staged functions can be thought of as a runtime macro.
At the first call of the function code can be generated, which then will get compiled in time and replaces the function definition. 
This makes the an OpenGL function call nearly twice as fast.
Like this, even C can be outperformed in terms of speed, as C doesn't have just in time compilation capabilities, so the function pointers can not be inlined like this. [benchmark pending, probably better in discussion though?]


\subsection{GLAbstraction}
GLAbstraction is the abstraction layer over ModernGL.
It wraps OpenGL primitives like Buffers and Textures in Julia objects and hooks them up to Julia's garbage collector.
Additionally, it implements convenient functions to load shader code and it makes it easy to feed the shader with the correct data types.
Besides wrapping OpenGL, it also offers the linear algebra needed for the various 3D transformation and camera code.
On top of that, it defines a perspective and orthographic camera type which can be used with signals to manipulate the parameters of the camera.


\subsection{GLWindow}
GLWindow is a lightweight wrapper around GLFW. GLFW is a C-Library, that offers cross-platform OpenGL window and context creation and event handling.
GLWindows is the abstraction layer, that builds upon a Julia wrapper of GLFW.
It mainly offers a screen type, which contains signals for all the different GLFW events (Mouse, Keyboard, etc...). 
It also offers a hierarchical structure for nesting screens in each other. 
All the screen areas are signals, which resize the screen area when they change. Like this, you can dynamically have the screen sizes depend on each other and react to resizing the window.



\subsection{GLVisualize}
GLVisualize implements the main functionality of this library.
It offers rendering of different primitives. GLVisiualize is designed with two intentions in mind: supplying a very simple interface consisting of just two functions and transport the data with as little conversions and copies to the GPU.
This allows to manipulate the data directly on the GPU, which is the fastest way to update dynamic data.
The interface to create visualizations is very simple and only consists of two functions:
\begin{lstlisting}
visualization 		  = visualize(data::T, style=Style{:default}; parameters...)
visualization, signal = edit(     data::T, style=Style{:default}; parameters...)
\end{lstlisting}

With this, the following data can be visualized:
\begin{itemize}
	\item Text (Vector of Glyphs)
	\item Height fields with different primitives (Matrix of height values)
	\item 3D bar plots (Matrix of height values)
	\item Images (Matrix of color values)
	\item Videos (Vector of Images)
	\item Volumes (3D Array of intensities)
	\item Particles (Vector of Points)
	\item Vector Fields (3D array of directional Vectors)
	\item Colors (Single Color values)
\end{itemize}

These can be integrated into the same scene. For all of these, it is possible to change their values interactively.
The edit function is making it easier to edit the values of the data.
It calls the visualize function to render the data type and then registers appropriate events to update the data.
Take a look at the text edit function. 
It first uploads the text to video memory and sets up the functionality to visualize it, and than updates the text data on the GPU according to the cursor position and keyboard input.

Up to now, there is only an edit function available for text fields, colors, numbers, vectors and matrices.


\subsubsection{Romeo}
