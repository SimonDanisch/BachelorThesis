\section{Conclusion}
In this work a fast 3D visualization for scientific computing has been presented. 
The initial goals and requirements where to use simple interfaces, being fast for animated and static data, ready for interaction and written in a way that it is easy to extend.
As can be seen in the benchmarks, in terms of speed the the goals have been reached. At least for the most basic tasks, Romeo does not show any weaknesses compared to other established libraries and is even often faster.
More complicated benchmarks with complex scenes have not been benchmarked and it will be interesting to see if there will be large performance drops due to the simple scene graph that is not multi-threaded and does not do any higher level optimizations.
The visualization API is as simple as it can be and seems to promise a steep learning curve.
If that turns out to be true for Romeo's users is an open question, which could not be answered as there are not that many users yet.
Some success has been achieved with creating the packages in a way, that they can be used by other people for their own projects. 
It is very promising, that there are already people extending Romeo even in this early stage.
Hopefully, this will gurantee all developed packages a steady flow of feature additionsm bug-reports and fixes. 

All in all, it was shown that Julia and Romeo build a steady foundation for any project which involves scientific computing, high performance needs and a heavy use of visualizations. 

\subsection{Future Work}

There is much to do as noted over the course of the thesis. The scene graph is very simple, there is no real multi-threading support, the anti-aliasing is sub optimal, a lot of important features are missing and the OpenGL version used is just mildly modern, compared to the features released recently. 
Staying state of the art will be a big challenge, especially while keeping downward compatibility for platforms that do not support the newest feature set.
One of the most exciting possibilities is to make Julia compile to the GPU directly, which could than be used to eliminate the last pieces of code that are not written in Julia. 
As \ac{LLVM} supports to compile to GPU back-ends, this might be possible in the future.
So things like ray picking, calculating normals, culling objects could in the future be done in Julia on the GPU, yielding superior performance while keeping a concise code base.