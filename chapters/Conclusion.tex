\section{Conclusion}

In this work, a fast 3D visualization for scientific computing has been presented. 
The initial goals and requirements were to use simple interfaces, being fast for animated and static data, ready for interaction and written in a way that it is easy to extend.
Many different visualization types have been realized with all parameters being animatable.
As can be seen in the benchmarks, in terms of speed the goals have been reached. 
At least for the most basic tasks, Romeo does not show any weakness compared to other established libraries and is even faster in many cases.
More complicated benchmarks with complex scenes have not been benchmarked and it will be interesting to see if there will be large performance drops due to the simple scene graph that is not multi-threaded and does not do any higher level optimizations yet.
The visualization API is very simple and seems to promise a steep learning curve.
If that turns out to be true for Romeo's users is an open question, which could not be answered as there are not that many users yet.
Some success has been achieved with creating the packages in a way, that they can be used by other people for their own projects. This has been proven valuable, as users reported and fixed bugs and added features to the packages.
It is very promising, that there are already people extending Romeo even in this early stage.

All in all, it has been shown that Julia and Romeo build a steady foundation for any project which involves scientific computing, high-performance needs and a heavy use of visualizations. 

\subsection{Future Work}

There is much to do as noted over the course of the thesis. 
The scene graph is very simple, there is no real multithreading support, the anti-aliasing is sub-optimal, a lot of important features are missing and the OpenGL version used is just mildly modern, compared to the features recently released. 
Staying state of the art will be a big challenge, especially while keeping downward compatibility for platforms that do not support the newest feature set.
One of the most exciting possibilities is to make Julia compile to the GPU directly. As \ac{LLVM} supports to compile to GPU backends this is a valid possibility.
Like this, the last pieces of code that are not written in Julia could be elimated. 
This would further unify the platform and will lower the complexity of the library. 

So things like ray picking, calculating normals, culling objects could in the future be done in Julia on the GPU, yielding superior performance while keeping a concise code base.
