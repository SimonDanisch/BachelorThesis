\section{Background}

In this chapter, a short overview will be given over the current state of the art for visualization inside the field of scientific computing.

\subsection{Related Work}

\subsubsection{The Julia Programming Language}

Bringing Julia's ease of use and speed to a dynamic visualization library is the declared goal.
So Julia plays a crucial role in this thesis. 
It is the most important previous work, as much as Julia is the main used technology.
This chapter gives a short introduction to the Julia Programming Language.

Julia was published in 2012, which makes it a very new language. It is currently at version 0.3.7 stable and 0.4 pre-release.
Following common versioning conventions this means Julia is still in an early release phase with the core features and names suspicable to change.
Julia is using the compiler infrastructure \ac{LLVM} to generate fast assembly code.

Julia is a multi paradigma language for scientific computing. 
Some of its most important features are multiple dispatch, a dynamic type system, macros, good performance and an interface to C and Python.
The focus on scientific computing means, that Julia's standard library is equipped with a lot of functions, data structures and specialized syntax for implementing complex math like linear algebra and statistics.
It promises to approach C speed, while being a dynamic language which is easy to use.
This is made possible by the compile process which can be described as statically compiled at runtime.
Julia uses a garbage collector, taking the task of memory management away from the programmer.
There are quite a few things Julia promises to the developer described which includes the following items:\cite{WhyJulia}.
\begin{itemize}
	\item C like performance
	\item native C interface
	\item macros like in Lisp
	\item mathematical notations like Matlab
	\item good at general purpose programming as python
	\item easy for statistics as R.
\end{itemize}
These are the reasons why Julia is well suited for implementing an interactive scientific visualization library.
Interactive visualizations have very hard demands on performance. 
60 frames per second are needed to feel comfortable, so there are only 0.016 seconds available for computing a single frame.
There should be no stutters and calling C-libraries should be simple and fast in order to communicate with the video driver.
This is one side, but the other is equally important:
You can do the scientific programming in the same language as you do the visualization.
Like this, Julia's native data types can be used without serialization, copies and the library can be extended by the Julia programmer.
Finally, Julia's concise and high-level coding style and the intereactive execution model makes it a lot easier to extend software.
This makes Julia a great foundation for any software.

\subsubsection{\ac{LLVM}}

\ac{LLVM} is an compiler infrastructure, which has front ends for different languages and compiles to different platforms like x86, ARM, \ac{OpenCL} and \ac{CUDA}. 
A language designer must create an \ac{AST} which than \ac{LLVM} can convert into \ac{LLVM} \ac{IR}. This \ac{IR} can than be heavily optimized. 
Every language that can be converted to \ac{LLVM} \ac{IR} can be combined at this level, going through the same optimizations in the end. This is yields superiour language interfacing, as inlining and other optimizations can be done over the boundary of one language.

\ac{LLVM}'s concept is effective, as you can accumulate state of the art optimizations in one place, making them accessible to many languages. Because of the many backends, the language can run on many architectures. While Julia does not support them all, it will hopefully be possible in the future. 
\ac{LLVM} is also used by Clang, the C/C++ front end for \ac{LLVM} rivaling \ac{gcc} and it is used by Apple's programming language Swift.
This makes \ac{LLVM} a solid basis for a programming language, as these are highly successful projects guaranteeing \ac{LLVM} further prospering.


\subsubsection{IJulia}
IJulia is the Julia language back-end for IPython.
IPython is a software stack, which was created to allow for interactive computing in Python.
It offers an interactive shell to execute python scripts, \ac{GUI} toolkits, tab completion and rich media visualizations.
It comes with a web based notebook, which enables you to write formated documentations together with data, inlined plots and executable program snippets. You can also formulate mathematical formulas in latex, which will get rendered and inlined nicely into an IJulia Notebook.
See figure \ref{fig:ijulianotebook} for an example.

IJulia has some similar goals compared to Romeo, but it has a different focus.
The notebook is completely web based, concentrates on 2D visualizations and interactivity is mostly limited to the programming and not the graphics.
3D graphics are possible via Three.js, which is a powerful 3D visualization library based on WebGL.
The current integration is just prototypical and limited to simple 3D meshes up to now.


\subsubsection{Matlab}

\ac{Matlab} is a numerical computing environment that comes with its own programming language.
It was created in 1984 by Cleve Moler. He designed it to leverage the effort of accessing LINPACK and EISPACK for his students.
Since then it grew to be a widely used tool for scientific computing in all areas, ranging from teaching to actual engineering uses in companies.
It offers a broad range of functionality, including matrix manipulation, plotting of functions and data, creation of user interfaces and interfacing with a range of languages like C/C++, Java Fortran and Python.

\ac{Matlab} itself is written in C, C++, Java and MATLAB.
It's proprietary software with a pricing of around \EUR{2000}\cite{MatlabPricing}, which can be extended via free, open source and proprietary modules like Simulink.

Romeo intends to lay out the ground work to provide something remotely similar together with Julia. It is quite far away in terms of functionality, but it builds upon a more modern architecture, which intends to solve some problems that have accumulated for Matlab.
While Julia 

\subsubsection{Mayavi and VTK}
\vspace{1em}
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.9\linewidth]{graphics/vtk.jpg}
    \captionof{figure}[VTK Capabilities]{Different visualizations done with VTK.}
    \label{fig:vtkgallery}
\end{minipage}
Mayavi is probably one of the biggest, open source library for interactive 3D visualizations.
It is written 99.9\% in python, but relies on \ac{VTK} for rendering.
\ac{VTK} is one of the most advanced scientific visualization library, with a huge amount of visualization types. In figure \ref{fig:vtkgallery} you can see some of the visualization taken from the \ac{VTK} gallery\cite{VTKGallery}.

Mayavi shares some of its goals with Romeo, namely\cite{MayaviGoals}
\begin{itemize}
	\item An (optional) rich user interface with dialogs to interact with all data and objects in the visualization.
	\item A simple and clean scripting interface in Python, including one-liners, or an object-oriented programming interface. Mayavi integrates seamlessly with numpy and scipy for 3D plotting and can even be used in IPython interactively, similarly to Matplotlib.
	\item The power of the VTK toolkit, harnessed through these interfaces, without forcing you to learn it.
\end{itemize}
Obviously, the python part is not a shared goal, but creating an interactive 3D visualization library deeply embedded into a language is.
Mayavi together with VTK is a very big project and in this sense not really comparable to Romeo.
It amounts to a total of 3.642.105 lines of code written in 29 languages. The statistics can be found in table \ref{table:ParaviewStatistic} and \ref{table:VTKStatistic}.
The biggest difference is, that Romeo is implemented in a scientific programming language, while Mayavis core uses VTK which is mainly implemented in C++.
This has two big implications:
Firstly, if the language doesn't have native C++ compatible data types and an overhead less C++ interface, shipping a large stream of data to VTK becomes slow.
Secondly, one must know C++ to extend VTK. This makes it difficult to create customized visualizations.

In contrast, Romeo is implemented in one language, making these tasks very simple and efficient.


\subsubsection{Vispy}

Vispy is yet another interactive 3D visualization library. It is from the goals and development status the closest to Romeo.
These include\cite{VispyGoals}:

\begin{itemize}
	\item High-quality interactive scientific plots with millions of points.
	\item Direct visualization of real-time data.
	\item Fast interactive visualization of 3D models (meshes, volume rendering).
	\item OpenGL visualization demos.
	\item Scientific GUIs with fast, scalable visualization widgets (Qt or IPython notebook with WebGL).
\end{itemize}
It is a fairly new library, promising to use modern OpenGL and state of the art performance.
This is very similar to Romeo's goals, with the only difference being that Romeo is implented in Julia while Vispy is implemented in Python.
So the only differenciation between Romeo and Vispy will be in performance and the concrete feature set.

